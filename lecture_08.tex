\section{Системи шифрування та цифровий підпис Рабіна}
\begin{flushright}
\emph{(Автор: Маша Коляда. Не редагувалось.)}
\par \emph{(Версія від 18 січня 2017 р.)}
\end{flushright}

Дана система шифрування та цифрового підпису використовує односторонню функцію Рабіна: $y=x^2 \bmod n$, де $n=p*q$, де  $p\ne q$, великі прості числа.

\textit{Побудова системи шифрування Рабіна користувачем А:}\\
\textbf{Схема шифрування Рабіна 1}\\
\ Зашифрування відкритого тексту користувачем $B$:
\begin{enumerate}
        \item Користувач А обирає прості числа(великі) $p$ и $q$, $p\ne q$. Зазвичай $p=2*p’+1$,  $q=2*q’+1$, где  $p’, q’$ - великі прості числа
        \item Користувач А обчислює $n=p*q$, де  $p,q$ – його секретний ключ
        \item Користувач А \textit{«оголошує»} відкритий ключ $n$, для зашифрування повідомлень до нього.
        \item Зашифрування повідомлення $M$, де $\sqrt{n}<M<n$,  користувачем $B$: $ C=M^2 \bmod n$ – шифртекст 
        \item Користувач $B$ відправляє повідомленя користувачу $A$.    
\end{enumerate}
\textbf{Зауваження}:  При $M^2<n$, підрахунок квадратного корня аналогічний до підрахунку квадратного кореня на множині дійсних чисел, що легко виконується.\\
Розшифрування шифртексту користувачем  А:
\begin{enumerate}
        \item   Використовуючи $p$ обчислює $\pm \beta_p=C^{\frac{1}{2}}\bmod p$
        \item Використовуючи $q$ обчисює $\pm \beta_q=C^{\frac{1}{2}}\bmod q$
        \item За китайською теоремою про лишки знаходить 4 корені $C^{\frac{1}{2}}\bmod n={(\pm \beta_p)*q*q^{-1}\bmod p +-( \beta_q)*p*p^{-1}\bmod q}$. Отримує  ${M_1,M_2,M_3,M_4}$.
        Обирає один з цих коренів за змістом.   
\end{enumerate}
\textbf{Схема шифровання Рабіна 2(коли n – число Блюма)}\\
\ Зашифрування  відкритого тексту $M$ : $\sqrt{n}<M<n$ користувачем В:
\begin{enumerate}
        \item Обчислює $M^2\bmod n=C$
        \item Обчислює 2 біта: %$b_1=$
        %\begin{cases}
        %0, \text{ якщо M парне} \\
        %1 \text{, інакше}
        %\end{cases}
        %$ b_2 =$
        %\begin{cases}
        % 0 \text{, якщо ($\frac{M}{n}$)= $-1 $,(символ Якобі)}\\
        % 1 \text{, якщо ($\frac{M}{n}$)=$1$}
        %\end{cases}
        \todo{(ПОМИЛКА. Оточення cases не працює в цьому фрагменті -- розібратись. -- С.Я.)}
        \item Формує зашифроване повідомлення $(C,b_1,b_2)$ та відправляє його користувачу А.   
\end{enumerate}
\ Розшифрування  $(C,b_1,b_2)$ користувачем  А:
\begin{enumerate}
        \item  Аналогічно схеми шифрування Рабіна 1 знаходить ${M_1,M_2,M_3,M_4}$
        \item Використовуючи $(b_1,b_2)$  обчислює $ (b^i_1, b^i_2) $ i=1,.,4 и  обирає $M_i$ у котрого $(b^i_1, b^i_2)= (b_1,b_2) $    
\end{enumerate}
\ Стійкість при атаці, на основі шифртексту (еквівалентна), повністю заснована на складності задачі факторизації. Схеми шифрування Рабіна 1 и 2 не стійкі  відносно атаки на основі вибраного шифртексту.

\textbf{Атака на схему шифрування Рабіна 1}
\begin{enumerate}
        \item Криптоаналітик Е підбирає послідовність
        відкритого тексту $M_1$….$M_k$, обчислює відповідні їм  $C_1$…$C_k$.
        \item Відправляє отриманий шифртекст $A$.
        \item  $A$ : $M'_1$….$M'_k$. Перевіряє $M_i=\pm M'_i$
        \item Якщо така пара знайшлась, то обчислює НСД($M_i\pm M'_i,n)=p$ або $q$.     
\end{enumerate}

\textbf{Атака на схему шифрування Рабіна 2}

\begin{enumerate}
        \item  Криптоаналітик $E$ обирає відкритий текст $M$. Обчислює ($b_1,b_2$)
        \item Обчислює $M^2\bmod n=C$
        \item Відправляє шифртекст ($C, b_1,b^{'}_2$), де $b^{'}_2=b_2 \oplus 1$
        \item Отримавши відкритий текст $M^{'}$, знає, що $M\ne M^{'}$, обчислює НСД($M_i\pm M^{'}_i,n)=p$ або $q$.
\end{enumerate}

\textbf{Схема цифрового підпису Рабіна}\\
\textit{Побудова схеми цифрового підпису Рабіна користувачем А}

\begin{enumerate}
        \item Обирає великі прості числа $p,q$: $p\ne q$
        \item Обчислює геш-функцію $h(x)$
        \item Оголошує $n=p*q$
        \item Оголошує відкритий ключ ($n, h(x)$) для перевірки цифрового підпису А     
\end{enumerate}
\ При цьому $p,q$ - секретний ключ користувача А для формування цифрового підпису.\\
\textit{Формування цифрового підпису А:}

\begin{enumerate}
        \item   $M =m_1m_2…m_k$. Генерує випадкову послідовність $R=r_1…r_s$.
        \item   Обчислює $h(M||R)=h(m_1…m_k+r_1…r_s)=H$
        \item Перевіряє, чи є $H$ квадратичним лишком за модулем $n$.
        \begin{enumerate}
                \item Якщо виконується $H^{\frac{p-1}{2}}\bmod p=1$ и $H^{\frac{q-1}{2}}\bmod q=1$, переходимо до кроку 4.
                \item інакше переходимо к кроку 1.
        \end{enumerate}
\ Якщо n-число Блюма, то в средньому, цей пункт виконується на 4й спробі
    \item       Обчислює $H^{\frac{1}{2}}\bmod n$:
    \begin{enumerate}
    \item       Використовуючи $p$ обчислює$\pm \beta_p=C^{\frac{1}{2}}\bmod p$
    \item Використовуючи $q$ обчислює $\pm \beta_q=C^{\frac{1}{2}}\bmod q$
    \item   За китайською теоремою про лишки знаходить 4 корені $C^{\frac{1}{2}}\bmod n={\pm \beta_p*q*q^{-1}\bmod p \pm ( \beta_q)*p*p^{-1}\bmod q}$ =>{ $M_1,M_2,M_3,M_4$}
\end{enumerate}
   \item Обирає один з коренів $\beta$, та формує підпис ($M,R, \beta$)
\end{enumerate}

\textit{Перевіка цифрового підпису користувачем В:}

\begin{enumerate}
        \item   ($M,R,\beta$) -> $M$,$R$,$\beta$
        \item Обчислює  $h(M||R)=h(m_1…m_k+r_1…r_s)=H$
        \item Перевіряє рівність :$ \beta^2 = H \bmod n$.
        \begin{enumerate}
                \item Якщо виконується, то підпис правильний
                \item Інакше, не правильний.
        \end{enumerate} 
\end{enumerate}
\ Складність зламування цифрового підпису Рабіна поліноміально еквівалентна складності задачі факторизації.