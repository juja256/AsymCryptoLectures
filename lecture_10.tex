\section{Криптосистеми на еліптичних кривих}
\begin{flushright}
\emph{(Автор: Оксана Науменко. Не редагувалось.)}
\par \emph{(Версія від 18 січня 2017 р.)}
\end{flushright}

Перші стандарт криптосистем на еліптичних кривих:\\
1999 рік -- ISO -- стандарт на базі цифрового підпису Ель-Гамаля;\\
2000 рік -- ECDSS -- американський стандарт на базі звичайного підпису Ель-Гамаля;\\
2001 рік -- ГОСТ Р34.10-2001 -- російський стандарт цифрового підпису;\\
2002 рік -- ДСТУ-4145-2002 -- український стандарт, який відрізняється від російського та американського (не являє собою кальку з російського стандарту)\\
Всі ці стандарти реалізують цифровий підпис Ель-Гамаля.\\
Існує множина різновидів Ель-Гамаля.\\
Рівняння підпису: $H=ks+rx$   $mod(p-1)$, тут $k$ - разовий секретний ключ (СК)\\
Рівняння перевірки підпису: $ak=bx+c$ $mod(p-1)$, $a, b, c = \pm 1, \pm H, \pm r, \pm s, \pm H\cdot r, \pm H\cdot s,\pm r \cdot s, \pm ...$\\
Всі стандарти розглядаються над різними полями.\\
ISO -- поле характеристики, більшої за 3, можуть бути як прості поля, так і розширені;\\
ГОСТ -- тільки прості поля, що мають велику характеристику;\\
ДСТУ -- поля характеристики 2, придумав - Кочубинський А.І.\\
\begin{center}
\textbf{ДСТУ-4145-2002\\}
\end{center}
\begin{enumerate}
        \item \underline{Вибір поля $F_{2^{m}}.$, $163\leq m \leq 509$}\\
        163 та 509 -- прості числа, і між ними зосереджено ще 60 простих чисел, тому для розглядання пропонуєть 60 полів характеристики 2.\\
        $m$ -- просте, тому що всі елементи мультиплікативної групи поля (крім одиниці) - примітивні.\\
        
        $F_{2^{2}}, F_{2^{3}}, F_{2^{5}}$ -- $p^{n-1}$ - просте, порядки максимальні.\\
                
        Серед 60 полів 14 мають нормальний оптимальний базис.\\
        \item Вибір еліптичної кривої (ЕК).\\
        Еліптична крива обов'язково повинна бути несуперсингулярною!\\
        $y^{2}+xy=x^{3}+ax^{2}+b$ (суперсингулярна має рівняння: $y^{2}+y=x^{3}+ax+b$)\\
        
        Операція ділення - дуже витратна
        операція, а для суперсингулярної кривої в рівнянні для пошуку кута нахилу немає ділення.\\
        \emph{MOV - атака:}\\
        (Р, 2Р, 3Р, ...) - циклічна група, що вкладена в мультиплікативну групу поля. ($F_{2^{m}}$ вкладена в $F_{2^{km}}$)\\
        Для суперсингулярних кривих: $k \leq $6 (тобто поле, в яке можна вкласти, не має бути більшим за $F_{2^{6m}}$)\\
        В задачі дискретного логарифма є метод аналізу таких полів(невеликих), тому криптосистеми, побудовані на суперсингулярних кривих, втрачають стійкість.\\
        
        Для несуперсингулярних кривих:\\
        (Р, 2Р, 3Р, ... , nP=$O_{E}$), n не ділиться на ($2^{km}-1$), k - різні\\
        E=$y^{2}$+$xy$+$x^{3}$+$ax^{2}$+$b$, $b\neq 0$, $a$=0,1 (всі інші $a$ будуть ізоморфні до $a$=0,1)\\
        $ord E$=$cn$, $n$ - велике просте число (всі елементи групи будуть примітивними)\\
        В стандарті запропоновано 15 кривих. $c$= 2 або $c$= 4 (чим менше значення $c$, тим краще), задані $a$, $b$.\\
        Стійкість на \emph{MOV-атаку} перевіряється до $k\leq 32$ (Для порівняння - в ISO перевіряється до $k\leq 20$, а це вже досить маленьке значення)\\
        На ЕК обирається точка $G\in E$ : $ord G$ = $n$ - базова точка (аналог $\alpha$ в ЦП Ель-Гамаля)\\
        \item Вибір алгоритма хешування.\\
        За замовчуванням використовується український стандарт хешування ДСТУ--34.311 (ГОСТ Р-34.11)\\
        Хеш має 256 біт, $n>2^{160}$\\
        Не забороняється використовувати інші хеші (при цьому додається ідентифікатор хешу).\\
        Абонент (А) обирає секретний ключ: $d_{A}$ - випадкове число в проміжку 0< $d_{A}$ <$n$, СК є постійним і видається центром сертифікації.\\
        Відкритий ключ А - точка еліптичної кривої: $Q_{A}=-d_{A}\cdot G$ (тобто точку (-$G$) складають з собою $d_{A}$ разів)\\
        Згадаємо: для несуперсингулярної кривої точка \textit{Р} має координати $x$ та $y$, точка -\textit{P} має координати $x$ та $x+y$.\\
        \item Процедура підпису.\\
        Маємо повідомлення $M$ : $H(M)$ - число, що має довжину 256 біт (інтерпретується як елемент поля $F_{2^{m}}$)\\
        Довжина хешу може не співпадати з довжиною елементів поля:\\
        --якщо $H(M)$>$h\in F_{2^{m}}$, відкидаємо старші біти;\\
        --якщо $H(M)$<$h\in F_{2^{m}}$, покладаємо старші біти нулями (00..0$H(M)$)\\
        $M$: $H(M)\rightarrow h \in F_{2^{m}}$, $h=0 \Rightarrow h$=1 (якщо відкинули старші біти і залишились лише самі нулі)\\
        Абонент обирає разовий ключ: 0<$k_{A}<n$.\\
        Абонент рахує $R$ = $k_{A} \cdot G$ (DOPISAT'''''')\\
        \textit{R} має координати ($x_{R}, y_{R}), x_{R} \in F_{2^{m}}$, $y=x_{R} \cdot h \in F_{2^{m}}$ (множимо як елементи поля $F_{2^{m}}$)\\
    Поліноми, що даються в полі $F_{2^{m}}$ - триноми або пентаноми - незвідні.\\
$y$ переводимо в число $r$<$n$.\\
Перша частина цифрового підпису : $r$.\\
Рівняння підпису : $S$ = $k_{A}$ + $d_{A} \cdot r$ $(mod n)$\\
ДСТУ має особливість, яка підвищує його стійкість : $h$ сховано мультиплікативним чином, а також перевагу в тому, що поля мають характеристику, рівну 2.\\

\item Сам підпис.\\

$DS = $($0$||$s$||$0$||$r$) - нарощування $s$, $r$ в старших бітах.
-- довжина повинна дорівнювати 16.\\
-- $0$||$s$, $0$||$r$ повинні бути рівними за довжиною.
Маємо вектор : ($iH$, $M$, $DS$), $i$ - індикатор.\\

\item Перевірка підпису.\\

$G$ помножене на число - аналог перевірки $\alpha^{k}$ в ЦП Ель-Гамаля.\\
$S \cdot G$ = $k_{A} \cdot G$ + $d_{A} \cdot G$
$\underbrace{k_{A} \cdot G}=S \cdot G - \underbrace{d_{A} \cdot G} \cdot r$, де $k_{A} \cdot G$ = $R$, $d_{A} \cdot G$ - відкритий ключ $Q_{A}\Rightarrow R'=S \cdot G + Q_{A} \cdot r$ - можна порахувати ($r$ - відомо).\\
$R'$ має координати ($x_{R'}, y_{R'}$).
Той, хто перевіряє підпис, робить ті самі дії, що і абонент, який ставить цей підпис:
$H(M) \in F_{2^{m}}, x_{R'} \cdot h=y \in F_{2^{m}}$
%$y \rightarrow r', (x_{R'}, y_{R'})=R \rightarrow r'$ (координата %$x$_{R'} повинна дорівнювати $x_{R}$) - перевірка рівності $r'$=$r$\\
$x_{R}$ - \emph{передпідпис}. \\
Дозволяється генерувати багато передпідписей, але потім знищувати їх.\\
\end{enumerate} 

\section{Цифрова готівка}
Особливість цифрової готівки - анонімність платника. ЦГ базується на алгоритмі сліпого цифрового підпису (на базі RSA).
\emph{Сліпий ЦП.}
Маємо $A$ - абонент, що вимагає цифрового підпису від $B$ та схему RSA з $n, e, d $\\
$A$: хоче, щоб $B$ поставив підпис, але не зміг прочитати повідомлення.\\
$ \underbrace{M \cdot r^{e}} \rightarrow B$, $r$ - випадкове число, таке, що ($r$, $n$)=1, $M \cdot r^{e} = M_{1}, r$ - осліплюючий множник (множник, що затемнює, засліплює)\\
$B$: (підписує $M_{1}) M_{1}^{d}=S mod n \longrightarrow A$\\
$A$: $M_{1}^{d} = M^{d} \cdot r^{ed} mod n = M^{d} mod n = S_{1}$\\
$S_{1} \cdot r^{-1} = M^{d} \cdot r^{-1} \cdot r = M^{d} mod n$\\
$B$ - той, хто підписує, і він не бачить повідомлення $M$.\\
\emph{Схема цифрової готівки.}\\
Маємо схему, що складається з трьох елементів: \textit{T} - торговець, \textit{Б}- банк, \textit{K}- клієнт. \textit{K} і \textit{T} відкривають рахунок в \textit{Б} (повинні покласти деяку суму грошей). \\
\textit{K} створює електронну купюру: \textit{(v, n)}, де \textit{v} - \emph{value} - номінал (наприклад, 100 доларів), \textit{n} - дуже велике випадкове число (номер купюри).\\
\textit{K} затемнює \textit{(v, n)} і відправляє до \textit{Б}, повідомляючи при цьому значення \textit{v}.\\
\textit{Б} підписує сліпою ЦП, не знаю при цьому \textit{n} купюри; \textit{Б} знімає з рахунка \textit{K} купюру зазначеного номіналу \textit{v}.\\
\\
Виникає питання: чому банк довіряє клієнтові? Адже він може зазначити будь-яку суму, в рази меншу, ніж потрібну. Для того, щоб банк повірив клієнтові, виконуються такі дії:\\
\textit{K} формує \textit{m} електронних купюр одного номіналу \textit{v} так, щоб ймовірність $\frac{1}{m}$ була малою : $(v, n_{1}), (v, n_{2}), ... , (v, n_{m}$) і надсилає \textit{Б}.\\
\textit{Б} випадковим чином обирає одну з купюр $1\leq j \leq m$ і просить надіслати сліпучий множник на всі, крім обраної j-тої купюри. \\
Таким чином \textit{Б} перевіряє: якщо всі номінали розкритих купюр \textit{v} співпадають, то \textit{Б} ставить свій підпис.\\
Потім \textit{K} надсилає електронну купюру \textit{T} :\textit{ (v, n, S)} - гроші (клієнт знімає сліпучий множник).\\
\textit{T} перевіряє підпис банку та надсилає свою електронну купюру до \textit{Б} $ \rightarrow $ \textit{Б} має $(v, n), n_{K}=n_{T}$.\\
Ще один варіант шахрайства: \textit{K} і \textit{T} можуть надіслати купюру з однаковим $n$. Для цього існує реєстр використованих купюр.\\
