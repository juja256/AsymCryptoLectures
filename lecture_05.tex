\section{Геш-функції}
\begin{flushright}
\emph{(Автор: Євген Грубіян. Не редагувалось.)}
\par \emph{(Версія від 18 січня 2017 р.)}
\end{flushright}

\textit{Геш-функція} - одностороння функція, яка перетворює блок даних довільного розміру в блок даних фіксованого розміру. При цьому прообразів для одного значення геш-функції може бути дуже багато, а знаходження бодай одного із них є дуже трудомістким. Однією із причин розробки геш-функцій стала необхідність підписувати повідомлення довільного розміру та перевіряти цілісність даних.

Геш-функції в криптографії використовується:
\begin{enumerate}
\item Для створення геш-образів для повідомлень цифрового підпису.
\item Для безпечного зберігання паролів.
\item Для автентифікації.
\item В криптопротоколах.
\item Для генерації випадкових послідовностей, функцій, ключів.
\item Для перевірки правильності обчислювальних операцій.
\end{enumerate}

Розглянем варіант цифрового підпису \textit{RSA} без геш-функцій:\\
Нехай абонент \textbf{A} має криптосистему \textit{RSA} з відкритим ключем \( \left( n, e \right) \) і таємним ключем \( d \).
\begin{algorithm}[Цифровий підпис \textit{RSA} без геш-функціїї]\ 
\begin{itemize}
\item \textbf{A} розбиває \( M \) на блоки: \( M = M_1 M_2 \dots M_t \), де \( |M_i|<n,\ i = \overline{1,\ t} \).
\item \textbf{A} обчислює цифровий підпис для кожного із блоків окремо \( S_i = M_i^d\ mod\ n \)
\item \textbf{A} формує підписане повідомлення \( \left(M, S_1 S_2 \dots S_t \right) \)
\end{itemize}
\end{algorithm}
Недоліки цього способу:
\begin{enumerate}
\item Трудоємність.\\
Очевидно, що чим більше блоків необхідно підписати тим більше часу потрібно витратити, тому даний варіант є не практичним з обчислювальної точки зору.
\item Атаки перестановкою і видаленням блоків. \\
Оскільки блоки підписуються незалежно криптоаналітик \textbf{E} може видаляти та переставляти блоки як йому завгодно без порушення правильності підпису, продукуючи повідомлення з вірним цифровим підписом, які \textbf{A} ніколи не підписував і не підписав би. 
\item Комутативні атаки. \\
Нехай \( A \) підписав два повідомлення \( \left( M_1,\ S_1 \right),\ \left( M_2,\ S_2 \right) \). Криптоаналітик \textbf{E} формує неправдиве повідомлення з вірним цифровим підписом \( \left(M_3,\ S_3 \right) \), де \( M_3 = M_1 M_2 \ mod\ n \), \( S_3 = S_1 S_2 \ mod\ n \). Перевірка цифрового підпису цього повідомлення дає \[ S_3^e \ mod\ n = (S_1 S_2)^e\ mod\ n = (M_1^d M_2^d)^e \ mod\ n = M_1^{de} M_2^{de} \ mod\ n = M_1 M_2\ mod\ n = M_3 \]
Тобто підпис правильний. І взагалі кажучи \( \forall (M_i,\ S_i),\ i = \overline{1,\ t} \) повідомлень, які підписав \textbf{A} можна скласти неправдиве повідомлення з вірним цифровим підписом: \( ( \widetilde{M},\ \widetilde{S} ) \), де \[ \widetilde{M} = \left( \prod_{i=1}^t M_i^{\alpha_i} \right) mod\ n,\ \widetilde{S} = \left( \prod_{i=1}^t S_i^{\alpha_i} \right) mod\ n, \ \alpha_i \in \Zring{+} \]
\item Атака з неявним використанням таємного ключа \( d \)\\
Нехай криптоаналітик \textbf{E} хоче щоб \textbf{A} підписав повідомлення \( M \), яке вигідне криптоаналітику. 
\begin{algorithm}[Атака з неявним використанням таємного ключа]\ 
\begin{itemize}
\item \textbf{E} вибирає деяке число \( r \colon gcd(r,n) = 1 \).
\item \textbf{E} обчислює \( \widetilde{M} = r^e M\ mod\ n \).
\item \textbf{E} відправляє повідомлення \( M \) для цифрового підпису \textbf{A}.
\item Якщо \textbf{A} підписав запропоноване повідомлення \( \widetilde{M} \), \textbf{E} отримує підписане повідомлення \( (\widetilde{M},\ \widetilde{S}) \) та може обчислити підпис початкового вигідного для \textbf{E} повідомлення \( M \):
\[ \widetilde{S} = \widetilde{M}^d\ mod\ n = r^{ed} M^d\ mod\ n = r M^d\ mod\ n\]
\[ S = M^d = \widetilde{S} r^{-1}\ mod\ n \]
\item \textbf{E} формує вигідне для нього підписане повідомлення \( \left( M,\ S \right) \). 
\end{itemize}
\end{algorithm}
\end{enumerate}

Введемо позначення:\\
\( \Zring{2} = {0, 1} \) - алфавіт із двох символів.\\
\( \Zring{2}^{*} \) - замикання Кліні алфавіту \( \Zring{2} \) (Множина послідовностей всіх довжин із алфавіту). 
\( \Zring{2}^{m} \) - множина послідовностей довжини \( m \).
\begin{mydef}
\textit{Геш-функцією} в криптографії називається відображення:\\
\[ h \colon \Zring{2}^{*} \rightarrow \Zring{2}^{m},\ m>1\]
яке має властивості:
\begin{enumerate}
\item \( \forall M \in \Zring{2}^{*} \) обчислення геш-образу \( H = h(M) \) швидке.
\item \( h(x) \) - обчислювально одностороння функція, тобто \( \forall H \in \Zring{2}^{m} \) неможливо знайти хоча б одне \( M \), таке що \( H = h(M) \).\\
\textit{Приклад}\\
\( m=256,\ ||M||=500 \). Тоді в середньому \( \forall H \in \Zring{2}^{m}\ \exists \frac{2^{500}}{2^{256}} = 2^{244} \) можливих \( M \). Тобто знайти таке повідомлення-прообраз випадково неможливо.
\item Геш-функція чутлива до змін входу, тобто має лавинні ефекти.
\item Слабка стійкість до колізій, тобто для кожного фіксованого повідомлення \( M \) неможливо знайти таке \( M' \neq M \) таке, що \( h(M) = h(M') \).
\item Сильна стійкість до колізій, тобто неможливо знайти хоча б одну пару повідомлень \( (M, M') \), таку що \( h(M) = h(M') \)
\end{enumerate}
\end{mydef}

\begin{mydef}
Геш-функція, яка має властивості 1-4 називається \textit{слабкою односторонньою геш-функцією}.
\end{mydef}

\begin{mydef}
Геш-функція, яка має властивості 1-5 називається \textit{сильною односторонньою геш-функцією}.
\end{mydef}

Розглянемо цифровий підпис \textit{RSA} до повідомлення \( M \) будь-якої довжини з геш-функцією \( h(x) \).
Нехай абонент \textbf{A} має криптосистему \textit{RSA} з відкритим ключем \( \left( n, e \right) \), таємним ключем \( d \) і відкриту геш-функцією \( h(x) \colon ||h|| = m,\ 2^{m} < n \)
\begin{remark}
Зазвичай довжина виходу геш-функції \( m \) складає 128, 160, 192, 256 або 512 біт. Найпоширенішими є геш-функції з \( m \) 128, 160, 256. На цих довжинах досягається компроміс між стійкістю до колізій та швидкістю обчислення геш-функції.
\end{remark}
\begin{algorithm}[Цифровий підпис \textit{RSA} з геш-функцією]\ 
\begin{itemize}
\item \textbf{A} обчислює значення геш-функції повідомлення \( M \): \( H = h(M) \)
\item \textbf{A} обчислює цифровий підпис: \( S = H^d\ mod\ n \)
\item \textbf{A} формує підписане повідомлення \( (M,\ S) \).
\end{itemize}
\end{algorithm}
Нехай підписане повідомлення \( (M,\ S) \) перевіряє абонент \textbf{B}.
\begin{algorithm}[Перевірка цифрового підпису \textit{RSA} з геш-функцією]\ 
\begin{itemize}
\item \textbf{B} розбиває \( (M,\ S) \) на \( M \) та \( S \) по формальним ознакам
\item \textbf{B} обчислює \( H = h(M) \)
\item \textbf{B} перевіряє рівність \( S^e\ mod\ n = H \). Якщо вона виконується, то цифровий підпис \textit{вірний}, якщо не виконується, то підпис \textit{не вірний}.
\end{itemize}
\end{algorithm}

Розглянемо можливості атак на цифровий підпис з геш-функцією. Основні атаки базуються на пошуці колізій в використаній геш-функції, тобто фактів однакових геш-значень при різних аругументах геш-функції.\\
Нехай криптоаналітик \textbf{E} намагається отримати вигідне для нього повідомлення з вірним цифровим підписом абонента \textbf{A}. Розглянемо наступні два варіанта атаки:
\begin{enumerate}
\item Якщо \textbf{E} має підписане \textbf{A} повідомлення \( (M,\ S) \)\\
\textbf{E} будує ряд повідомлень \( M_1, M_2, \dots, M_t\colon M_i \neq M \) та обчислює їхні геш-значення \( H_1, H_2, \dots, H_t\colon H_i = h(M_i) \).\\
Пободуємо ймовірнісну модель атаки, в припущенні, що всі геш-значення рівноймовірні на множині \( \Zring{2}^m \). Позначимо \( P_1, Q_1 \) - ймовірності слабкої колізії і відсутності слабкої колізії відповідно. Тоді:
\[ Q_1 = \left(1-\frac{1}{2^m} \right)^t,\ P_1 = 1 - \left(1-\frac{1}{2^m} \right)^t \]
Таким чином асимптотично можна записати:
\[ Q_1 = e^{-t/2^m},\ P_1 = 1-e^{-t/2^m}\ m,t\rightarrow \infty \]
Середня кількість необхідних повідомлень для здійснення атаки знаходженням колізії:
\[ t = 2^m ln\frac{1}{1-P_1} \]
\item Якщо криптоаналітик \textbf{E} не чекає підписаного \textbf{A} повідомлення(\textit{атака Ювала}).\\
\textbf{E} будує ряди повідомлень прийнятних \( M_1, M_2, \dots, M_t \) та неприйнятних \( \widetilde{M_1}, \widetilde{M_2}, \dots, \widetilde{M_t} \) для \textbf{A} повідомлень, тобто таких, які він би підписав і не підписав ніколи відповідно та обчислює їхні геш-значення \( H_1, H_2, \dots, H_t \) та \( \widetilde{H_1}, \widetilde{H_2}, \dots, \widetilde{H_t} \) відповідно. Якщо знайдеться така пара індексів \( (i,\ j) \), що \( H_i = \widetilde{H_j} \), то криптоаналітик \textbf{E} посилає повідомлення \( (M_i,\ H_i) \) для цифрового підпису \textbf{A} та отримавши підписане повідомлення \( (M_i,\ S_i) \) формує неправдиве повідомлення з вірним цифровим підписом \( \left( \widetilde{M_j},\ S_i \right) \).\\
Будуючи ймовірнісну модель по аналогії з попереднім випадком варто зазначити, що в якості ймовірностей \( P_2,\ Q_2 \) варто брати ймовірності сильної колізії та її відсутності:
\[ Q_2 = \left(1-\frac{1}{2^m} \right)^{t^2},\ P_2 = 1 - \left(1-\frac{1}{2^m} \right)^{t^2} \]
Варто зазначити що при однаковому \( t \) ймовірність сильної колізії більша за ймовірність слабкої. \\
Середнє число повідомлень для успішної атаки складатиме:
\[ t = 2^{m/2} \sqrt{ln\frac{1}{1-P_2}} \]
\end{enumerate}
