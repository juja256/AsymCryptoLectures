\section{Важкооборотні функції із секретом. Важкооборотна функція RSA}
\begin{flushright}
\emph{(Автор: Олександр Богуцький.  Редагувалось.)}
\par \emph{(Версія від 22 січня 2017 р.)}
\end{flushright}

\begin{mydef}
 Важкооборотною функцією із секретом (лазівкою) називається відображення :
\begin{equation}
y = f_{\text{k}}(x): X \rightarrow Y,
\end{equation}
що залежить від параметру k, таке, що:
\begin{enumerate}

\item $\forall k, x$ існує поліноміальний (ефективний) алгоритм обчислення $y = f_{\text{k}}(x)$. При цьому знати $k$ необов'язково.

\item При невідомому $k$ майже для будь-яких $k, y$ не існує поліноміального алгоритму обчислення оберненої функції $f_{\text{k}} ^{-1} (y)$.

\item При відомому $k$ існує поліноміальний алгоритм обчислення $f_{\text{k}} ^{-1} (y) \; \forall k, x$.
\end{enumerate}

Під ефективністю алгоритму розуміємо те, що обчислення ведуться за долі секунди. У той час як обчислення неефективних алгоритмів займатимуть мільярди років, а то й більше. 
\end{mydef}

Зауважимо, що функція $y = f_{\text{k}}(x)$ не обов'язково повинна бути бієкцією.

Як і раніше, потужності $X, Y$ дуже великі.

\begin{mydef}
 Важкооборотною функцією із таємницею RSA називається функція 
\begin{equation} \label{eq:3.1} 
y = x ^{e} \bmod n,
\end{equation}
при чому $n = p \cdot q,\; q \neq p$ ~--- великі прості числа, $(e, \varphi(n)) = 1     $. Зазвичай $p = 2p\prime + 1,\; q = 2q\prime + 1$, де $p\prime,\; q\prime$ ~--- прості.
\end{mydef}
Секрет функції RSA: $q, \; p$, а також $\varphi  (n)$.

\pagebreak 

Розглянемо оцінки складності:
\begin{enumerate}

\item Для будь-якого $x$ складність обчислення \eqref{eq:3.1} :  $L_{1} \leq 2 \log {n}$.

\item При невідомих $q, \; p,\;\varphi  (n)$ складність обчислення оберненої функції (тобто добування дискретного кореня): $L_{2} = O(\sqrt n)$.

Доведено субекспоненційну оцінку складності обернення фунції :
\[ L_{3} = exp\{ (  \mbox{с}_{0} + O(1)) \ln ^{1/2} n (\ln\ln n) ^ {1/2}) \}. \]

Крім того, вважається, але строго не доведено, що можна досягти такої складності обчислення:
\[ 
L_{4} = exp\{ (  \mbox{с}_{0} + O(1)) \ln ^{1/3} n (\ln\ln n) ^ {2/3}) \}.
\]

\item При відомих $p,\;q$ складність обернення $L_{5} \leq 2 \log n$.

\end{enumerate}

Помітимо, що якщо $x \in X = \{ 0, 1, ..., n-1 \}$, то функція RSA \eqref{eq:3.1} ~--- бієкція.

Тепер розглянемо як будується криптосистема RSA з використанням функції \eqref{eq:3.1}.

\subsection{Побудова криптосистеми шифрування та цифрового підпису RSA користувачем A}

\begin{enumerate}
\item Вибір великих простих $p,\; q,\; p \neq q$.

\item Обчислення $n = p \cdot q, \; \varphi(n)=(p-1)(q-1)$.

\item Знаходження $e:\;1<e<\varphi(n),\;(e,\varphi(n))=1$.

\item Обчислення $d$ із рівняння $d \cdot e = 1 \bmod \varphi(n)$, тобто $d = e ^{-1} \bmod \varphi(n)$.

\item Оголошення відкритого ключа $(n,e)$ для зашифрування повідомлень для користувача $A$ та для перевірки цифрового підпису $A$.
При цьому $d$ ~--- це секретий ключ $A$ для розшифрування шифр текстів, відправлених користувачеві, і для формування цифрового підпису $A$.

\end{enumerate}
Зрозуміло, що $\varphi (n)$ -- теж секрет $A$.

Якщо $\varphi (n)$ відомо, то криптоаналітик складає систему рівнянь з двома невідомими:
\begin{equation*}
\begin{cases}
    n = p \cdot q, \\
    (p-1)(q-1) = \varphi (n)
\end{cases},
\end{equation*}
та розв'язує її.

Обернена до RSA функція обчислюється легко : 
\begin{equation} 
x = y ^{d} \bmod n.
\end{equation}

\subsection{Зашифрування повідомлення користувачем B}

Зашифрування повідомлення $M \; (1<M<n)$ відбувається наступним чином. Користувач, використовуючи відкритий ключ користувача $A$, обчислює : 
\begin{equation}
C = M^e \bmod n.
\end{equation}
Отриманий шифр текст $C$ відправляється користувачеві $A$.

\subsection{Розшифрування шифртексту C користувачем A}

Розшифрувати шифр текст може лише користувач $A$, який знає секретний ключ. Здійснюється це теж всьго лиш в одну операцію : 
\begin{equation} \label{eq:3.2} 
M = C ^ d \bmod n.
\end{equation}

Дане твердження вимагає доведення, оскільки \eqref{eq:3.2} не є очевидним фактом.

\begin{proof}
Для доведення \eqref{eq:3.2} розглянема 3 випадки:

\begin{enumerate}
\item $(M,n) = 1$.
\item $(M,n) > 1, \; M\divisible p, \; M \notdivisible q$ .
\item $(M,n) > 1, \; M \notdivisible p, \; M \divisible q$ .
\end{enumerate}

На практиці, можливий лише перший випадок, оскільки ймовірність того, що $M$ та $n$ не взаємопрості, порядку $\frac{1}{2^{500}}$ (для випадку коли \textsl{n}--1024 біти), що практично дорівнює нулеві.
Звісно, якби така ймовірність була високою, то здійснювалась би атака на взлом. Вибираючи $M$, шукали б НСД, що не дорівнює 1. Тоді за алгоритмом Евкліда, знаходяться $p$ та $q$. \\

\textit{Випадок 1}: $(M,n) = 1$. \\
Тоді $C ^ d \bmod n = M ^ {ed} \bmod n$. \\
Оскільки $ed = 1 \bmod \varphi (n)$, то існує таке ціле число $t$, що $ed = t \cdot \varphi (n) + 1 $. \\
Тому $M ^ {ed} \bmod n = M ^ {t \varphi (n) + 1} \bmod n = (M ^ {\varphi (n)})^ t  M \bmod n$.\\
 Оскільки за теоремою Ейлера $M ^ {\varphi (n)} \bmod n = 1$, то $(M ^ {\varphi (n)})^ t  M \bmod n = M$.\\
 
\textit{Випадок 2}.\\
 Розглянемо $C ^ d \bmod q = M ^ {ed} \bmod q = M ^ {(q-1)(p-1) \cdot t + 1} \bmod q = (M ^ {q-1}) ^ {(p-1)t}M \bmod q$.\\ Оскільки $M \notdivisible q$, то $M ^ {q-1} \bmod q = 1$ за малою теоремою Ферма. \\
Отримуємо $(M ^ {q-1}) ^ {(p-1)t}M \bmod q = M \Rightarrow C ^ d \bmod p = M ^{ed} \bmod p = M$. \\
Оскільки $M \divisible p$, то $M ^{ed} \bmod p = M \bmod p$. У результаті отримуємо співвідношення:
\begin{equation*}
\begin{cases}
    C ^ d \bmod p = M \\
    C ^ d \bmod q = M
\end{cases}
\end{equation*}
За китайською теоремою про лишки, отримуємо $C ^ d \bmod n = M$.\\
Міркування щодо випадку 3 аналогічні міркуванням випадку 2.
\end{proof}

\subsection{Задачі цифрового підпису}

Основними задачами цифрового підпису є:

\begin{enumerate}
\item Підтвердження справжності (цілісності) повідомлення.
\item Підтвердження справжності джерела (автора) повідомлення.
\item Забезпечення неможливості підробки цифрового підпису.
\item Забезпечення неможливості відмови від цифрового підпису.
\item Можливість багакратної перевірки цифрового підпису різними користувачами без зміни системи цифрового підпису. 
\item Юридична значимість.
\end{enumerate}

\subsection{Цифровий підпис RSA}
Цифровий підпис формується просто. Користувач використовує власний секретний ключ для підпису повідомлення:
\begin{equation}
S = M ^d \bmod n.
\end{equation}
Далі відбувається формування підписаного повідомлення: до $M$ дописується цифровий підпис $S$. Отже, підписане повідомлення виглядає так ~--- $(M, S)$.

Перевірка цифрового підпису користувачем $B$ здійснюється наступним чином: отримане підписане повідомлення $(M, S)$ розбивається за формальними ознаками на $M$ та $S$, і перевіряється рівність 
\begin{equation} \label{eq:3.3} 
S ^ e \bmod n = M.
\end{equation}
Якщо \eqref{eq:3.3} виконується, то цифровий підпис вірний, тобто повідомлення справжнє, відправити та сформувати його міг лише користувач $A$ і ніхто інший. При наявності іншого результату, це свідчитиме про змінене повідомлення або підроблений цифровий підпис.
Якщо нема спотворень, то \eqref{eq:3.3} виконується, оскільки $S ^ e \bmod n = M ^ {ed} \bmod n = M$ (доведення аналогічне попередньому).

Стійкість системи RSA базується на складності задачі факторизації (розклад великих чисел на множники). Якщо модуль $n$ розкладений на множники $q$ та $p$, то можна обернути важкооборотну функцію та взломати RSA, підробити цифровий підпис.

Не доведено, що якщо за шифр текстом в RSA знайдено відкритий текст, то можна розкласти $n$ на множники $p$ та $q$.
