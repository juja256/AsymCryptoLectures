\section{Важкооборотні функції із секретом. Важкооборотна функція RSA}
\begin{flushright}
\emph{(Автор: Олександр Богуцький. Трохи редагувалось.)}
\par \emph{(Версія від 19 січня 2017 р.)}
\end{flushright}

Озн. 1. Важкооборотною функцією із секретом (лазівкою) називається відображення 
\begin{equation}
y = f_{\text{k}}(x): X \rightarrow Y,
\end{equation}
що залежить від параметру k, таке, що:\par
1) $\forall k, x$ існує поліноміальний (ефективний) алгоритм обчислення $y = f_{\text{k}}(x)$. При цьому знати $k$ необов'язково.
\par2) При невідомому $k$ майже для будь-яких $k, y$ не існує поліноміального алгоритму обчислення оберненої функції $f_{\text{k}} ^{-1} (y)$.
\par3) При відомому $k$ існує поліноміальний алгоритм обчислення $f_{\text{k}} ^{-1} (y) \; \forall k, x$.

Під ефективністю алгоритму розуміємо те, що обчислення ведуться за долі секунди. У той час як обчислення неефективних алгоритмів займатимуть мільярди років, а то й більше. 

Зауважимо, що функція $y = f_{\text{k}}(x)$ не обов'язково повинна бути бієкцією.

Як і раніше, потужності $X, Y$ дуже великі.

Озн. 2. Важкооборотною функцією із таємницею RSA називається функція 
\begin{equation} \label{eq:3.1} 
y = x ^{e} \bmod n,
\end{equation}
при чому $n = p \cdot q,\; q \neq p$ ~--- великі прості числа, $(e, \varphi(n)) = 1     $. Зазвичай $p = 2p\prime + 1,\; q = 2q\prime + 1$, де $p\prime,\; q\prime$ ~--- прості.

Секрет функції RSA: $q, \; p$, а також $\varphi  (n)$.

Розглянемо оцінки складності:
\par1. Для будь-якого $x$ складність обчислення \eqref{eq:3.1} $L_{1} \leq 2 \log {n}$.
\par2. При невідомих $q, \; p,\;\varphi  (n)$ складність обчислення оберненої функції (тобто добування дискретного кореня) $L_{2} = O(\sqrt n)$.

Доведено субекспоненційну оцінку складності обернення фунції  $L_{3} = exp\{ (  \mbox{с}_{0} + O(1)) \ln ^{1/2} n (\ln\ln n) ^ {1/2}) \}$.

Крім того, вважається, але строго не доведено, що можна досягти такої складності обчислення $L_{4} = exp\{ (  \mbox{с}_{0} + O(1)) \ln ^{1/3} n (\ln\ln n) ^ {2/3}) \}$.

\par3. При відомих $p,\;q$ складність обернення $L_{5} \leq 2 \log n$.

Помітимо, що якщо $x \in X = \{ 0, 1, ..., n-1 \}$, то функція RSA \eqref{eq:3.1} ~--- бієкція.

Тепер розглянемо, як будується криптосистема RSA з використанням функції \eqref{eq:3.1}.

\subsection{Побудова криптосистеми шифрування та цифрового підпису RSA користувачем A}

\par1. Вибір великих простих $p,\; q,\; p \neq q$.

\par2. Обчислення $n = p \cdot q, \; \varphi(n)=(p-1)(q-1)$.

\par3. Знаходження $e:\;1<e<\varphi(n),\;(e,\varphi(n))=1$.

\par4. Обчислення $d$ із рівняння $d \cdot e = 1 \bmod \varphi(n)$, тобто $d = e ^{-1} \bmod \varphi(n)$.

\par5. "Оголошення" відкритого ключа $(n,e)$ для зашифрування повідомлень для користувача $A$ та для перевірки цифрового підпису $A$.
При цьому $d$ ~--- це секретий ключ $A$ для розшифрування шифр текстів, відправлених користувачеві, і для формування цифрового підпису $A$.

Зрозуміло, що $\varphi (n)$ ~--- теж секрет $A$.

Якщо $\varphi (n)$ відомо, то криптоаналітик складає систему рівнянь з двома невідомими:
\begin{equation*}
\begin{cases}
    n = p \cdot q, \\
    (p-1)(q-1) = \varphi (n)
\end{cases},
\end{equation*}
та розв'язує її.

Обернена до RSA функція обчислюється легко ~---
\begin{equation} 
x = y ^{d} \bmod n.
\end{equation}

\subsection{Зашифрування повідомлення користувачем B}

Зашифрування повідомлення $M \; (1<M<n)$ відбувається наступним чином. Користувач, використовуючи відкритий ключ користувача $A$, обчислює 
\begin{equation}
C = M^e \bmod n.
\end{equation}
Отриманий шифр текст $C$ відправляється користувачеві $A$.

\subsection{Розшифрування шифртексту C користувачем A}

Розшифрувати шифр текст може лише користувач $A$, який знає секретний ключ. Здійснюється це теж всьго лиш в одну операцію.
\begin{equation} \label{eq:3.2} 
M = C ^ d \bmod n.
\end{equation}

Дане твердження вимагає доведення, оскільки \eqref{eq:3.2} не є офевидним фактом.
\begin{proof}
Для доведення \eqref{eq:2} розглянема 3 випадки:
\par1) $(M,n) = 1$.
\par2) $(M,n) > 1, \; M \vdots p, \; M \not\vdots q$.
\par3) $(M,n) > 1, \; M \not \vdots p, \; M \vdots q$.
\\
На практиці, можливий лише перший випадок, оскільки ймовірність того, що $M$ та $n$ не взаємопрості, порядку $1/2^{500}$, що практично дорівнює нулеві.
Звісно, якби така ймовірність була високою, то здійснювалась би атака на взлом. Вибираючи $M$, шукали б НСД, що не дорівнює 1. Тоді за алгоритмом Евкліда, знаходяться $p$ та $q$.\\
Розглянемо перший випадок: $(M,n) = 1$. Тоді $C ^ d \bmod n = M ^ {ed} \bmod n$. Оскільки $ed = 1 \bmod \varphi (n)$, то існує таке ціле число $t$, що $ed = t \cdot \varphi (n) + 1 $. Тому $M ^ {ed} \bmod n = M ^ {t \varphi (n) + 1} \bmod n = (M ^ {\varphi (n)}) ^ t \cdot M \bmod n$. Оскільки за теоремою Ейлера $M ^ {\varphi (n)} \bmod n = 1$, то $(M ^ {\varphi (n)}) ^ t \cdot M \bmod n = M$.\\
Випадок 2. Розглянемо $C ^ d \bmod q = M ^ {ed} \bmod q = M ^ {(q-1)(p-1) \cdot t + 1} \bmod q = (M ^ {q-1}) ^ {(p-1)t} \cdot M \bmod q$. Оскільки $M \not\vdots q$, то $M ^ {q-1} \bmod q = 1$ за малою теоремою Ферма. Отримуємо $(M ^ {q-1}) ^ {(p-1)t} \cdot M \bmod q = M$. $C ^ d \bmod p = M ^{ed} \bmod p$. Оскільки $M \vdots p$, то $M ^{ed} mod p = M \bmod p$. У результаті отримуємо співвідношення:
\begin{equation*}
\begin{cases}
    C ^ d \bmod p = M, \\
    C ^ d \bmod q = M
\end{cases}.
\end{equation*}
За китайською теоремою про лишки, отримуємо $C ^ d \bmod n = M$.\\
Міркування щодо випадку 3 аналогічні міркуванням випадку 2.
\end{proof}

\subsection{Задачі цифрового підпису}

Основними задачами цифрового підпису є:

\par1. Підтвердження справжності (цілісності) повідомлення.
\par2. Підтвердження справжності джерела (автора) повідомлення.
\par3. Забезпечення неможливості підробки цифрового підпису.
\par4. Забезпечення неможливості відмови від цифрового підпису.
\par5. Можливість багакратної перевірки цифрового підпису різними користувачами без зміни системи цифрового підпису. 
\par6. Юридична значимість.

\subsection{Цифровий підпис RSA}
Цифровий підпис формується просто. Користувач використовує власний секретний ключ для підпису повідомлення:
\begin{equation}
S = M ^d \bmod n.
\end{equation}
Далі відбувається формування підписаного повідомлення: до $M$ дописується цифровий підпис $S$. Отже, підписане повідомлення виглядає так ~--- $(M, S)$.

Перевірка цифрового підпису користувачем $B$ здійснюється наступним чином: отримане підписане повідомлення $(M, S)$ розбивається за формальними ознаками на $M$ та $S$, і перевіряється рівність 
\begin{equation} \label{eq:3.3} 
S ^ e \bmod n = M.
\end{equation}
Якщо \eqref{eq:3.3} виконується, то цифровий підпис вірний, тобто повідомлення справжнє, відправити та сформувати його міг лише користувач $A$ і ніхто інший. При наявності іншого результату, це свідчитиме про змінене повідомлення або підроблений цифровий підпис.
Якщо нема спотворень, то \eqref{eq:3.3} виконується, оскільки $S ^ e \bmod n = M ^ {ed} \bmod n = M$ (доведення аналогічне попередньому).

Стійкість системи RSA базується на складності задачі факторизації (розклад великих чисел на множники). Якщо модуль $n$ розкладений на множники $q$ та $p$, то можна обернути важкооборотну функцію та взломати RSA, підробити цифровий підпис.

Не доведено, що якщо за шифр текстом в RSA знайдено відкритий текст, то можна розкласти $n$ на множники $p$ та $q$.
